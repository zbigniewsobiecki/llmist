/**
 * Event handler sugar for cleaner event processing.
 *
 * Instead of verbose if/else chains, use named handlers
 * for each event type.
 *
 * @example
 * ```typescript
 * await agent.runWith({
 *   onText: (content) => console.log("LLM:", content),
 *   onGadgetResult: (result) => console.log("Result:", result.result),
 * });
 * ```
 */

import type { StreamEvent } from "../gadgets/types.js";

/**
 * Named event handlers for different event types.
 */
export interface EventHandlers {
  /** Called when text is generated by the LLM */
  onText?: (content: string) => void | Promise<void>;

  /** Called when a gadget is about to be executed */
  onGadgetCall?: (call: {
    gadgetName: string;
    parameters?: Record<string, unknown>;
    parametersYaml: string;
  }) => void | Promise<void>;

  /** Called when a gadget execution completes */
  onGadgetResult?: (result: {
    gadgetName: string;
    result?: string;
    error?: string;
    parameters: Record<string, unknown>;
  }) => void | Promise<void>;

  /** Called when human input is required */
  onHumanInputRequired?: (data: { question: string; gadgetName: string }) => void | Promise<void>;

  /** Called for any other event type */
  onOther?: (event: StreamEvent) => void | Promise<void>;
}

/**
 * Helper to run an agent with named event handlers.
 *
 * @param agentGenerator - Agent's run() async generator
 * @param handlers - Named event handlers
 *
 * @example
 * ```typescript
 * await runWithHandlers(agent.run(), {
 *   onText: (text) => console.log("LLM:", text),
 *   onGadgetResult: (result) => console.log("Result:", result.result),
 * });
 * ```
 */
export async function runWithHandlers(
  agentGenerator: AsyncGenerator<StreamEvent>,
  handlers: EventHandlers,
): Promise<void> {
  for await (const event of agentGenerator) {
    switch (event.type) {
      case "text":
        if (handlers.onText) {
          await handlers.onText(event.content);
        }
        break;

      case "gadget_call":
        if (handlers.onGadgetCall) {
          await handlers.onGadgetCall({
            gadgetName: event.call.gadgetName,
            parameters: event.call.parameters,
            parametersYaml: event.call.parametersYaml,
          });
        }
        break;

      case "gadget_result":
        if (handlers.onGadgetResult) {
          await handlers.onGadgetResult(event.result);
        }
        break;

      case "human_input_required":
        if (handlers.onHumanInputRequired) {
          await handlers.onHumanInputRequired({
            question: event.question,
            gadgetName: event.gadgetName,
          });
        }
        break;

      default:
        if (handlers.onOther) {
          await handlers.onOther(event);
        }
        break;
    }
  }
}

/**
 * Helper to collect events by type.
 *
 * @param agentGenerator - Agent's run() async generator
 * @param collect - Object specifying which event types to collect
 * @returns Object with collected events
 *
 * @example
 * ```typescript
 * const { text, gadgetResults } = await collectEvents(agent.run(), {
 *   text: true,
 *   gadgetResults: true,
 * });
 *
 * console.log("Full response:", text.join(""));
 * console.log("Gadget calls:", gadgetResults.length);
 * ```
 */
export async function collectEvents(
  agentGenerator: AsyncGenerator<StreamEvent>,
  collect: {
    text?: boolean;
    gadgetCalls?: boolean;
    gadgetResults?: boolean;
  },
): Promise<{
  text: string[];
  gadgetCalls: Array<{ gadgetName: string; parameters: Record<string, unknown> }>;
  gadgetResults: Array<{
    gadgetName: string;
    result?: string;
    error?: string;
    parameters: Record<string, unknown>;
  }>;
}> {
  const result = {
    text: [] as string[],
    gadgetCalls: [] as Array<{ gadgetName: string; parameters: Record<string, unknown> }>,
    gadgetResults: [] as Array<{
      gadgetName: string;
      result?: string;
      error?: string;
      parameters: Record<string, unknown>;
    }>,
  };

  for await (const event of agentGenerator) {
    switch (event.type) {
      case "text":
        if (collect.text) {
          result.text.push(event.content);
        }
        break;

      case "gadget_call":
        if (collect.gadgetCalls && event.call.parameters) {
          result.gadgetCalls.push({
            gadgetName: event.call.gadgetName,
            parameters: event.call.parameters,
          });
        }
        break;

      case "gadget_result":
        if (collect.gadgetResults) {
          result.gadgetResults.push(event.result);
        }
        break;
    }
  }

  return result;
}

/**
 * Helper to collect only text from an agent run.
 *
 * @param agentGenerator - Agent's run() async generator
 * @returns Combined text response
 *
 * @example
 * ```typescript
 * const response = await collectText(agent.run());
 * console.log(response);
 * ```
 */
export async function collectText(agentGenerator: AsyncGenerator<StreamEvent>): Promise<string> {
  const chunks: string[] = [];

  for await (const event of agentGenerator) {
    if (event.type === "text") {
      chunks.push(event.content);
    }
  }

  return chunks.join("");
}
